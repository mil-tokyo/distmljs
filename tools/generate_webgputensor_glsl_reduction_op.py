# Generates shader/webgpu/autogen/sum_*.glsl

import os

package_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
dst_dir = os.path.join(package_root, "shader/webgpu/autogen")
os.makedirs(dst_dir, exist_ok=True)


DTYPE_TO_SCALAR_TYPE = {
    "float32": "float",
    "int32": "int",
    "uint8": "uint",
    "bool": "uint",
}


def generateDecomposeDim(dim) -> str:
    source = "uint dec_tmp = i;\n"
    for d in range(dim-1, -1, -1):
        source += f"uint todim{d} = dec_tmp % toShape{d};\n"
        if d > 0:
            source += f"dec_tmp = dec_tmp / toShape{d};\n"
    return source


def generateForLoop(toDim, redDim) -> str:
    if toDim > 0:
        source = f"""uint ofs = {"+".join([f"todim{d}*toShapeStrides{d}" for d in range(toDim)])};\n"""
    else:
        source = f"""uint ofs = 0;"""
    for d in range(redDim):
        source += f"for (uint red{d}=0; red{d} < reductionShape{d}; red{d}++) {{\n"
    if redDim > 0:
        source += f"""v += array_x.numbers[ofs + {"+".join([f"red{d}*reductionShapeStrides{d}" for d in range(redDim)])}];\n"""
    else:
        source += f"""v += array_x.numbers[ofs];\n"""
    for d in range(redDim):
        source += "}\n"
    return source


for t in ["float32", "int32", "uint8", "bool"]:
    for toDim in range(4):
        for redDim in range(4):
            kernel_name = f"sum_{t}_{toDim}_{redDim}"

            scalar_type = DTYPE_TO_SCALAR_TYPE[t]
            source = f"""#version 450

    // Auto-generated by tools/generate_webgputensor_glsl_copy_op.py

    layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

    layout(std430, set = 0, binding = 0) readonly buffer arrayX {{
    {scalar_type} numbers[];
    }} array_x;

    layout(std430, set = 0, binding = 1) buffer arrayY {{
    {scalar_type} numbers[];
    }} array_y;

    layout(std430, set = 0, binding = 2) readonly buffer Meta {{
    uint len;
    {f'uint {",".join([f"toShape{d}" for d in range(toDim)])};' if toDim > 0 else ""}
    {f'uint {",".join([f"toShapeStrides{d}" for d in range(toDim)])};' if toDim > 0 else ""}
    {f'uint {",".join([f"reductionShape{d}" for d in range(redDim)])};' if redDim > 0 else ""}
    {f'uint {",".join([f"reductionShapeStrides{d}" for d in range(redDim)])};' if redDim > 0 else ""}
    }} meta;

    void main() {{
    uint len = meta.len;
    {f'uint {",".join([f"toShape{d}=meta.toShape{d}" for d in range(toDim)])};' if toDim > 0 else ""}
    {f'uint {",".join([f"toShapeStrides{d}=meta.toShapeStrides{d}" for d in range(toDim)])};' if toDim > 0 else ""}
    {f'uint {",".join([f"reductionShape{d}=meta.reductionShape{d}" for d in range(redDim)])};' if redDim > 0 else ""}
    {f'uint {",".join([f"reductionShapeStrides{d}=meta.reductionShapeStrides{d}" for d in range(redDim)])};' if redDim > 0 else ""}
    for (uint i = gl_GlobalInvocationID.x; i < len; i += 4096) {{
        {generateDecomposeDim(toDim)}

        {scalar_type} v = {scalar_type}(0);
        {generateForLoop(toDim, redDim)}
        array_y.numbers[i] = v;

    }}
    }}

    """
            with open(os.path.join(dst_dir, kernel_name + ".glsl"), "w") as f:
                f.write(source)
