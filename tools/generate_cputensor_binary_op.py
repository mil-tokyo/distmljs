# Generates src/tensor/cpuTensorCore/binary.ts

import os

package_root = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
dst_path = os.path.join(package_root, "src/tensor/cpuTensorCore/binary.ts")

header = """// Auto-generated by tools/generate_cputensor_binary_op.py
import { TypedArrayTypes } from '../../dtype';
import { arrayEqual } from '../../util';
import { CPUTensor } from '../cpuTensor';
import { getMultiBroadcastShape } from '../shapeUtil';

"""

op_template = """// functions for %%NAME%%
function %%NAME%%BC1(
  dl: TypedArrayTypes,
  dr: TypedArrayTypes,
  dy: TypedArrayTypes,
  shape: ReadonlyArray<number>,
  allStrides: ReadonlyArray<ReadonlyArray<number>>
) {
  const [s0] = shape;
  const [[lt0], [rt0]] = allStrides;
  let id = 0;
  for (let t0 = 0; t0 < s0; t0++) {
    const lhs = dl[t0 * lt0];
    const rhs = dr[t0 * rt0];
    dy[id++] = %%OP%%;
  }
}

function %%NAME%%BC2(
  dl: TypedArrayTypes,
  dr: TypedArrayTypes,
  dy: TypedArrayTypes,
  shape: ReadonlyArray<number>,
  allStrides: ReadonlyArray<ReadonlyArray<number>>
) {
  const [s0, s1] = shape;
  const [[lt0, lt1], [rt0, rt1]] = allStrides;
  let id = 0;
  for (let t0 = 0; t0 < s0; t0++) {
    for (let t1 = 0; t1 < s1; t1++) {
      const lhs = dl[t0 * lt0 + t1 * lt1];
      const rhs = dr[t0 * rt0 + t1 * rt1];
      dy[id++] = %%OP%%;
    }
  }
}

function %%NAME%%BC3(
  dl: TypedArrayTypes,
  dr: TypedArrayTypes,
  dy: TypedArrayTypes,
  shape: ReadonlyArray<number>,
  allStrides: ReadonlyArray<ReadonlyArray<number>>
) {
  const [s0, s1, s2] = shape;
  const [[lt0, lt1, lt2], [rt0, rt1, rt2]] = allStrides;
  let id = 0;
  for (let t0 = 0; t0 < s0; t0++) {
    for (let t1 = 0; t1 < s1; t1++) {
      for (let t2 = 0; t2 < s2; t2++) {
        const lhs = dl[t0 * lt0 + t1 * lt1 + t2 * lt2];
        const rhs = dr[t0 * rt0 + t1 * rt1 + t2 * rt2];
        dy[id++] = %%OP%%;
      }
    }
  }
}

function %%NAME%%BC4(
  dl: TypedArrayTypes,
  dr: TypedArrayTypes,
  dy: TypedArrayTypes,
  shape: ReadonlyArray<number>,
  allStrides: ReadonlyArray<ReadonlyArray<number>>
) {
  const [s0, s1, s2, s3] = shape;
  const [[lt0, lt1, lt2, lt3], [rt0, rt1, rt2, rt3]] = allStrides;
  let id = 0;
  for (let t0 = 0; t0 < s0; t0++) {
    for (let t1 = 0; t1 < s1; t1++) {
      for (let t2 = 0; t2 < s2; t2++) {
        for (let t3 = 0; t3 < s3; t3++) {
          const lhs = dl[t0 * lt0 + t1 * lt1 + t2 * lt2 + t3 * lt3];
          const rhs = dr[t0 * rt0 + t1 * rt1 + t2 * rt2 + t3 * rt3];
          dy[id++] = %%OP%%;
        }
      }
    }
  }
}

function %%NAME%%BC(lhs: CPUTensor, rhs: CPUTensor): CPUTensor {
  const { shape, allStrides } = getMultiBroadcastShape([lhs.shape, rhs.shape]);

  const output = CPUTensor.zeros(shape);
  const dl = lhs.getBuffer().data;
  const dr = rhs.getBuffer().data;
  const dy = output.getBuffer().data;
  switch (shape.length) {
    case 1:
      %%NAME%%BC1(dl, dr, dy, shape, allStrides);
      break;
    case 2:
      %%NAME%%BC2(dl, dr, dy, shape, allStrides);
      break;
    case 3:
      %%NAME%%BC3(dl, dr, dy, shape, allStrides);
      break;
    case 4:
      %%NAME%%BC4(dl, dr, dy, shape, allStrides);
      break;
    default:
      throw new Error('Broadcasting to more than 4D is not yet implemented');
  }
  return output;
}

function %%NAME%%S(lhs: CPUTensor, rhs: CPUTensor): CPUTensor {
  const output = CPUTensor.zeros(lhs.shape);
  const dl = lhs.getBuffer().data;
  const dr = rhs.getBuffer().data;
  const dy = output.getBuffer().data;
  for (let i = 0; i < output.size; i++) {
    const lhs = dl[i];
    const rhs = dr[i];
    dy[i] = %%OP%%;
  }
  return output;
}

export function core%%NAME%%(lhs: CPUTensor, rhs: CPUTensor): CPUTensor {
  // TODO: type check
  if (!arrayEqual(lhs.shape, rhs.shape)) {
    return %%NAME%%BC(lhs, rhs);
  } else {
    return %%NAME%%S(lhs, rhs);
  }
}
"""

source = header
for name, op in sorted([
    ["add", "lhs + rhs"],
    ["sub", "lhs - rhs"],
    ["mul", "lhs * rhs"],
    ["div", "lhs / rhs"],
    ["pow", "Math.pow(lhs, rhs)"]
]):
    source += op_template.replace("%%NAME%%", name).replace("%%OP%%", op)

with open(dst_path, "w") as f:
    f.write(source)
