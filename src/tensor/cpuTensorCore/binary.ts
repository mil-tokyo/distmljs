// Auto-generated by tools/generate_cputensor_binary_op.py
import { TypedArrayTypes } from '../../dtype';
import { arrayEqual } from '../../util';
import { CPUTensor } from '../cpuTensor';
import { getMultiBroadcastShape } from '../shapeUtil';

// functions for add
function addBC1(
  dl: TypedArrayTypes,
  dr: TypedArrayTypes,
  dy: TypedArrayTypes,
  shape: ReadonlyArray<number>,
  allStrides: ReadonlyArray<ReadonlyArray<number>>
) {
  const [s0] = shape;
  const [[lt0], [rt0]] = allStrides;
  let id = 0;
  for (let t0 = 0; t0 < s0; t0++) {
    const lhs = dl[t0 * lt0];
    const rhs = dr[t0 * rt0];
    dy[id++] = lhs + rhs;
  }
}

function addBC2(
  dl: TypedArrayTypes,
  dr: TypedArrayTypes,
  dy: TypedArrayTypes,
  shape: ReadonlyArray<number>,
  allStrides: ReadonlyArray<ReadonlyArray<number>>
) {
  const [s0, s1] = shape;
  const [[lt0, lt1], [rt0, rt1]] = allStrides;
  let id = 0;
  for (let t0 = 0; t0 < s0; t0++) {
    for (let t1 = 0; t1 < s1; t1++) {
      const lhs = dl[t0 * lt0 + t1 * lt1];
      const rhs = dr[t0 * rt0 + t1 * rt1];
      dy[id++] = lhs + rhs;
    }
  }
}

function addBC3(
  dl: TypedArrayTypes,
  dr: TypedArrayTypes,
  dy: TypedArrayTypes,
  shape: ReadonlyArray<number>,
  allStrides: ReadonlyArray<ReadonlyArray<number>>
) {
  const [s0, s1, s2] = shape;
  const [[lt0, lt1, lt2], [rt0, rt1, rt2]] = allStrides;
  let id = 0;
  for (let t0 = 0; t0 < s0; t0++) {
    for (let t1 = 0; t1 < s1; t1++) {
      for (let t2 = 0; t2 < s2; t2++) {
        const lhs = dl[t0 * lt0 + t1 * lt1 + t2 * lt2];
        const rhs = dr[t0 * rt0 + t1 * rt1 + t2 * rt2];
        dy[id++] = lhs + rhs;
      }
    }
  }
}

function addBC4(
  dl: TypedArrayTypes,
  dr: TypedArrayTypes,
  dy: TypedArrayTypes,
  shape: ReadonlyArray<number>,
  allStrides: ReadonlyArray<ReadonlyArray<number>>
) {
  const [s0, s1, s2, s3] = shape;
  const [[lt0, lt1, lt2, lt3], [rt0, rt1, rt2, rt3]] = allStrides;
  let id = 0;
  for (let t0 = 0; t0 < s0; t0++) {
    for (let t1 = 0; t1 < s1; t1++) {
      for (let t2 = 0; t2 < s2; t2++) {
        for (let t3 = 0; t3 < s3; t3++) {
          const lhs = dl[t0 * lt0 + t1 * lt1 + t2 * lt2 + t3 * lt3];
          const rhs = dr[t0 * rt0 + t1 * rt1 + t2 * rt2 + t3 * rt3];
          dy[id++] = lhs + rhs;
        }
      }
    }
  }
}

function addBC(lhs: CPUTensor, rhs: CPUTensor): CPUTensor {
  const { shape, allStrides } = getMultiBroadcastShape([lhs.shape, rhs.shape]);

  const output = CPUTensor.zeros(shape);
  const dl = lhs.getBuffer().data;
  const dr = rhs.getBuffer().data;
  const dy = output.getBuffer().data;
  switch (shape.length) {
    case 1:
      addBC1(dl, dr, dy, shape, allStrides);
      break;
    case 2:
      addBC2(dl, dr, dy, shape, allStrides);
      break;
    case 3:
      addBC3(dl, dr, dy, shape, allStrides);
      break;
    case 4:
      addBC4(dl, dr, dy, shape, allStrides);
      break;
    default:
      throw new Error('Broadcasting to more than 4D is not yet implemented');
  }
  return output;
}

function addS(lhs: CPUTensor, rhs: CPUTensor): CPUTensor {
  const output = CPUTensor.zeros(lhs.shape);
  const dl = lhs.getBuffer().data;
  const dr = rhs.getBuffer().data;
  const dy = output.getBuffer().data;
  for (let i = 0; i < output.size; i++) {
    const lhs = dl[i];
    const rhs = dr[i];
    dy[i] = lhs + rhs;
  }
  return output;
}

export function coreadd(lhs: CPUTensor, rhs: CPUTensor): CPUTensor {
  // TODO: type check
  if (!arrayEqual(lhs.shape, rhs.shape)) {
    return addBC(lhs, rhs);
  } else {
    return addS(lhs, rhs);
  }
}
// functions for div
function divBC1(
  dl: TypedArrayTypes,
  dr: TypedArrayTypes,
  dy: TypedArrayTypes,
  shape: ReadonlyArray<number>,
  allStrides: ReadonlyArray<ReadonlyArray<number>>
) {
  const [s0] = shape;
  const [[lt0], [rt0]] = allStrides;
  let id = 0;
  for (let t0 = 0; t0 < s0; t0++) {
    const lhs = dl[t0 * lt0];
    const rhs = dr[t0 * rt0];
    dy[id++] = lhs / rhs;
  }
}

function divBC2(
  dl: TypedArrayTypes,
  dr: TypedArrayTypes,
  dy: TypedArrayTypes,
  shape: ReadonlyArray<number>,
  allStrides: ReadonlyArray<ReadonlyArray<number>>
) {
  const [s0, s1] = shape;
  const [[lt0, lt1], [rt0, rt1]] = allStrides;
  let id = 0;
  for (let t0 = 0; t0 < s0; t0++) {
    for (let t1 = 0; t1 < s1; t1++) {
      const lhs = dl[t0 * lt0 + t1 * lt1];
      const rhs = dr[t0 * rt0 + t1 * rt1];
      dy[id++] = lhs / rhs;
    }
  }
}

function divBC3(
  dl: TypedArrayTypes,
  dr: TypedArrayTypes,
  dy: TypedArrayTypes,
  shape: ReadonlyArray<number>,
  allStrides: ReadonlyArray<ReadonlyArray<number>>
) {
  const [s0, s1, s2] = shape;
  const [[lt0, lt1, lt2], [rt0, rt1, rt2]] = allStrides;
  let id = 0;
  for (let t0 = 0; t0 < s0; t0++) {
    for (let t1 = 0; t1 < s1; t1++) {
      for (let t2 = 0; t2 < s2; t2++) {
        const lhs = dl[t0 * lt0 + t1 * lt1 + t2 * lt2];
        const rhs = dr[t0 * rt0 + t1 * rt1 + t2 * rt2];
        dy[id++] = lhs / rhs;
      }
    }
  }
}

function divBC4(
  dl: TypedArrayTypes,
  dr: TypedArrayTypes,
  dy: TypedArrayTypes,
  shape: ReadonlyArray<number>,
  allStrides: ReadonlyArray<ReadonlyArray<number>>
) {
  const [s0, s1, s2, s3] = shape;
  const [[lt0, lt1, lt2, lt3], [rt0, rt1, rt2, rt3]] = allStrides;
  let id = 0;
  for (let t0 = 0; t0 < s0; t0++) {
    for (let t1 = 0; t1 < s1; t1++) {
      for (let t2 = 0; t2 < s2; t2++) {
        for (let t3 = 0; t3 < s3; t3++) {
          const lhs = dl[t0 * lt0 + t1 * lt1 + t2 * lt2 + t3 * lt3];
          const rhs = dr[t0 * rt0 + t1 * rt1 + t2 * rt2 + t3 * rt3];
          dy[id++] = lhs / rhs;
        }
      }
    }
  }
}

function divBC(lhs: CPUTensor, rhs: CPUTensor): CPUTensor {
  const { shape, allStrides } = getMultiBroadcastShape([lhs.shape, rhs.shape]);

  const output = CPUTensor.zeros(shape);
  const dl = lhs.getBuffer().data;
  const dr = rhs.getBuffer().data;
  const dy = output.getBuffer().data;
  switch (shape.length) {
    case 1:
      divBC1(dl, dr, dy, shape, allStrides);
      break;
    case 2:
      divBC2(dl, dr, dy, shape, allStrides);
      break;
    case 3:
      divBC3(dl, dr, dy, shape, allStrides);
      break;
    case 4:
      divBC4(dl, dr, dy, shape, allStrides);
      break;
    default:
      throw new Error('Broadcasting to more than 4D is not yet implemented');
  }
  return output;
}

function divS(lhs: CPUTensor, rhs: CPUTensor): CPUTensor {
  const output = CPUTensor.zeros(lhs.shape);
  const dl = lhs.getBuffer().data;
  const dr = rhs.getBuffer().data;
  const dy = output.getBuffer().data;
  for (let i = 0; i < output.size; i++) {
    const lhs = dl[i];
    const rhs = dr[i];
    dy[i] = lhs / rhs;
  }
  return output;
}

export function corediv(lhs: CPUTensor, rhs: CPUTensor): CPUTensor {
  // TODO: type check
  if (!arrayEqual(lhs.shape, rhs.shape)) {
    return divBC(lhs, rhs);
  } else {
    return divS(lhs, rhs);
  }
}
// functions for mul
function mulBC1(
  dl: TypedArrayTypes,
  dr: TypedArrayTypes,
  dy: TypedArrayTypes,
  shape: ReadonlyArray<number>,
  allStrides: ReadonlyArray<ReadonlyArray<number>>
) {
  const [s0] = shape;
  const [[lt0], [rt0]] = allStrides;
  let id = 0;
  for (let t0 = 0; t0 < s0; t0++) {
    const lhs = dl[t0 * lt0];
    const rhs = dr[t0 * rt0];
    dy[id++] = lhs * rhs;
  }
}

function mulBC2(
  dl: TypedArrayTypes,
  dr: TypedArrayTypes,
  dy: TypedArrayTypes,
  shape: ReadonlyArray<number>,
  allStrides: ReadonlyArray<ReadonlyArray<number>>
) {
  const [s0, s1] = shape;
  const [[lt0, lt1], [rt0, rt1]] = allStrides;
  let id = 0;
  for (let t0 = 0; t0 < s0; t0++) {
    for (let t1 = 0; t1 < s1; t1++) {
      const lhs = dl[t0 * lt0 + t1 * lt1];
      const rhs = dr[t0 * rt0 + t1 * rt1];
      dy[id++] = lhs * rhs;
    }
  }
}

function mulBC3(
  dl: TypedArrayTypes,
  dr: TypedArrayTypes,
  dy: TypedArrayTypes,
  shape: ReadonlyArray<number>,
  allStrides: ReadonlyArray<ReadonlyArray<number>>
) {
  const [s0, s1, s2] = shape;
  const [[lt0, lt1, lt2], [rt0, rt1, rt2]] = allStrides;
  let id = 0;
  for (let t0 = 0; t0 < s0; t0++) {
    for (let t1 = 0; t1 < s1; t1++) {
      for (let t2 = 0; t2 < s2; t2++) {
        const lhs = dl[t0 * lt0 + t1 * lt1 + t2 * lt2];
        const rhs = dr[t0 * rt0 + t1 * rt1 + t2 * rt2];
        dy[id++] = lhs * rhs;
      }
    }
  }
}

function mulBC4(
  dl: TypedArrayTypes,
  dr: TypedArrayTypes,
  dy: TypedArrayTypes,
  shape: ReadonlyArray<number>,
  allStrides: ReadonlyArray<ReadonlyArray<number>>
) {
  const [s0, s1, s2, s3] = shape;
  const [[lt0, lt1, lt2, lt3], [rt0, rt1, rt2, rt3]] = allStrides;
  let id = 0;
  for (let t0 = 0; t0 < s0; t0++) {
    for (let t1 = 0; t1 < s1; t1++) {
      for (let t2 = 0; t2 < s2; t2++) {
        for (let t3 = 0; t3 < s3; t3++) {
          const lhs = dl[t0 * lt0 + t1 * lt1 + t2 * lt2 + t3 * lt3];
          const rhs = dr[t0 * rt0 + t1 * rt1 + t2 * rt2 + t3 * rt3];
          dy[id++] = lhs * rhs;
        }
      }
    }
  }
}

function mulBC(lhs: CPUTensor, rhs: CPUTensor): CPUTensor {
  const { shape, allStrides } = getMultiBroadcastShape([lhs.shape, rhs.shape]);

  const output = CPUTensor.zeros(shape);
  const dl = lhs.getBuffer().data;
  const dr = rhs.getBuffer().data;
  const dy = output.getBuffer().data;
  switch (shape.length) {
    case 1:
      mulBC1(dl, dr, dy, shape, allStrides);
      break;
    case 2:
      mulBC2(dl, dr, dy, shape, allStrides);
      break;
    case 3:
      mulBC3(dl, dr, dy, shape, allStrides);
      break;
    case 4:
      mulBC4(dl, dr, dy, shape, allStrides);
      break;
    default:
      throw new Error('Broadcasting to more than 4D is not yet implemented');
  }
  return output;
}

function mulS(lhs: CPUTensor, rhs: CPUTensor): CPUTensor {
  const output = CPUTensor.zeros(lhs.shape);
  const dl = lhs.getBuffer().data;
  const dr = rhs.getBuffer().data;
  const dy = output.getBuffer().data;
  for (let i = 0; i < output.size; i++) {
    const lhs = dl[i];
    const rhs = dr[i];
    dy[i] = lhs * rhs;
  }
  return output;
}

export function coremul(lhs: CPUTensor, rhs: CPUTensor): CPUTensor {
  // TODO: type check
  if (!arrayEqual(lhs.shape, rhs.shape)) {
    return mulBC(lhs, rhs);
  } else {
    return mulS(lhs, rhs);
  }
}
// functions for pow
function powBC1(
  dl: TypedArrayTypes,
  dr: TypedArrayTypes,
  dy: TypedArrayTypes,
  shape: ReadonlyArray<number>,
  allStrides: ReadonlyArray<ReadonlyArray<number>>
) {
  const [s0] = shape;
  const [[lt0], [rt0]] = allStrides;
  let id = 0;
  for (let t0 = 0; t0 < s0; t0++) {
    const lhs = dl[t0 * lt0];
    const rhs = dr[t0 * rt0];
    dy[id++] = Math.pow(lhs, rhs);
  }
}

function powBC2(
  dl: TypedArrayTypes,
  dr: TypedArrayTypes,
  dy: TypedArrayTypes,
  shape: ReadonlyArray<number>,
  allStrides: ReadonlyArray<ReadonlyArray<number>>
) {
  const [s0, s1] = shape;
  const [[lt0, lt1], [rt0, rt1]] = allStrides;
  let id = 0;
  for (let t0 = 0; t0 < s0; t0++) {
    for (let t1 = 0; t1 < s1; t1++) {
      const lhs = dl[t0 * lt0 + t1 * lt1];
      const rhs = dr[t0 * rt0 + t1 * rt1];
      dy[id++] = Math.pow(lhs, rhs);
    }
  }
}

function powBC3(
  dl: TypedArrayTypes,
  dr: TypedArrayTypes,
  dy: TypedArrayTypes,
  shape: ReadonlyArray<number>,
  allStrides: ReadonlyArray<ReadonlyArray<number>>
) {
  const [s0, s1, s2] = shape;
  const [[lt0, lt1, lt2], [rt0, rt1, rt2]] = allStrides;
  let id = 0;
  for (let t0 = 0; t0 < s0; t0++) {
    for (let t1 = 0; t1 < s1; t1++) {
      for (let t2 = 0; t2 < s2; t2++) {
        const lhs = dl[t0 * lt0 + t1 * lt1 + t2 * lt2];
        const rhs = dr[t0 * rt0 + t1 * rt1 + t2 * rt2];
        dy[id++] = Math.pow(lhs, rhs);
      }
    }
  }
}

function powBC4(
  dl: TypedArrayTypes,
  dr: TypedArrayTypes,
  dy: TypedArrayTypes,
  shape: ReadonlyArray<number>,
  allStrides: ReadonlyArray<ReadonlyArray<number>>
) {
  const [s0, s1, s2, s3] = shape;
  const [[lt0, lt1, lt2, lt3], [rt0, rt1, rt2, rt3]] = allStrides;
  let id = 0;
  for (let t0 = 0; t0 < s0; t0++) {
    for (let t1 = 0; t1 < s1; t1++) {
      for (let t2 = 0; t2 < s2; t2++) {
        for (let t3 = 0; t3 < s3; t3++) {
          const lhs = dl[t0 * lt0 + t1 * lt1 + t2 * lt2 + t3 * lt3];
          const rhs = dr[t0 * rt0 + t1 * rt1 + t2 * rt2 + t3 * rt3];
          dy[id++] = Math.pow(lhs, rhs);
        }
      }
    }
  }
}

function powBC(lhs: CPUTensor, rhs: CPUTensor): CPUTensor {
  const { shape, allStrides } = getMultiBroadcastShape([lhs.shape, rhs.shape]);

  const output = CPUTensor.zeros(shape);
  const dl = lhs.getBuffer().data;
  const dr = rhs.getBuffer().data;
  const dy = output.getBuffer().data;
  switch (shape.length) {
    case 1:
      powBC1(dl, dr, dy, shape, allStrides);
      break;
    case 2:
      powBC2(dl, dr, dy, shape, allStrides);
      break;
    case 3:
      powBC3(dl, dr, dy, shape, allStrides);
      break;
    case 4:
      powBC4(dl, dr, dy, shape, allStrides);
      break;
    default:
      throw new Error('Broadcasting to more than 4D is not yet implemented');
  }
  return output;
}

function powS(lhs: CPUTensor, rhs: CPUTensor): CPUTensor {
  const output = CPUTensor.zeros(lhs.shape);
  const dl = lhs.getBuffer().data;
  const dr = rhs.getBuffer().data;
  const dy = output.getBuffer().data;
  for (let i = 0; i < output.size; i++) {
    const lhs = dl[i];
    const rhs = dr[i];
    dy[i] = Math.pow(lhs, rhs);
  }
  return output;
}

export function corepow(lhs: CPUTensor, rhs: CPUTensor): CPUTensor {
  // TODO: type check
  if (!arrayEqual(lhs.shape, rhs.shape)) {
    return powBC(lhs, rhs);
  } else {
    return powS(lhs, rhs);
  }
}
// functions for sub
function subBC1(
  dl: TypedArrayTypes,
  dr: TypedArrayTypes,
  dy: TypedArrayTypes,
  shape: ReadonlyArray<number>,
  allStrides: ReadonlyArray<ReadonlyArray<number>>
) {
  const [s0] = shape;
  const [[lt0], [rt0]] = allStrides;
  let id = 0;
  for (let t0 = 0; t0 < s0; t0++) {
    const lhs = dl[t0 * lt0];
    const rhs = dr[t0 * rt0];
    dy[id++] = lhs - rhs;
  }
}

function subBC2(
  dl: TypedArrayTypes,
  dr: TypedArrayTypes,
  dy: TypedArrayTypes,
  shape: ReadonlyArray<number>,
  allStrides: ReadonlyArray<ReadonlyArray<number>>
) {
  const [s0, s1] = shape;
  const [[lt0, lt1], [rt0, rt1]] = allStrides;
  let id = 0;
  for (let t0 = 0; t0 < s0; t0++) {
    for (let t1 = 0; t1 < s1; t1++) {
      const lhs = dl[t0 * lt0 + t1 * lt1];
      const rhs = dr[t0 * rt0 + t1 * rt1];
      dy[id++] = lhs - rhs;
    }
  }
}

function subBC3(
  dl: TypedArrayTypes,
  dr: TypedArrayTypes,
  dy: TypedArrayTypes,
  shape: ReadonlyArray<number>,
  allStrides: ReadonlyArray<ReadonlyArray<number>>
) {
  const [s0, s1, s2] = shape;
  const [[lt0, lt1, lt2], [rt0, rt1, rt2]] = allStrides;
  let id = 0;
  for (let t0 = 0; t0 < s0; t0++) {
    for (let t1 = 0; t1 < s1; t1++) {
      for (let t2 = 0; t2 < s2; t2++) {
        const lhs = dl[t0 * lt0 + t1 * lt1 + t2 * lt2];
        const rhs = dr[t0 * rt0 + t1 * rt1 + t2 * rt2];
        dy[id++] = lhs - rhs;
      }
    }
  }
}

function subBC4(
  dl: TypedArrayTypes,
  dr: TypedArrayTypes,
  dy: TypedArrayTypes,
  shape: ReadonlyArray<number>,
  allStrides: ReadonlyArray<ReadonlyArray<number>>
) {
  const [s0, s1, s2, s3] = shape;
  const [[lt0, lt1, lt2, lt3], [rt0, rt1, rt2, rt3]] = allStrides;
  let id = 0;
  for (let t0 = 0; t0 < s0; t0++) {
    for (let t1 = 0; t1 < s1; t1++) {
      for (let t2 = 0; t2 < s2; t2++) {
        for (let t3 = 0; t3 < s3; t3++) {
          const lhs = dl[t0 * lt0 + t1 * lt1 + t2 * lt2 + t3 * lt3];
          const rhs = dr[t0 * rt0 + t1 * rt1 + t2 * rt2 + t3 * rt3];
          dy[id++] = lhs - rhs;
        }
      }
    }
  }
}

function subBC(lhs: CPUTensor, rhs: CPUTensor): CPUTensor {
  const { shape, allStrides } = getMultiBroadcastShape([lhs.shape, rhs.shape]);

  const output = CPUTensor.zeros(shape);
  const dl = lhs.getBuffer().data;
  const dr = rhs.getBuffer().data;
  const dy = output.getBuffer().data;
  switch (shape.length) {
    case 1:
      subBC1(dl, dr, dy, shape, allStrides);
      break;
    case 2:
      subBC2(dl, dr, dy, shape, allStrides);
      break;
    case 3:
      subBC3(dl, dr, dy, shape, allStrides);
      break;
    case 4:
      subBC4(dl, dr, dy, shape, allStrides);
      break;
    default:
      throw new Error('Broadcasting to more than 4D is not yet implemented');
  }
  return output;
}

function subS(lhs: CPUTensor, rhs: CPUTensor): CPUTensor {
  const output = CPUTensor.zeros(lhs.shape);
  const dl = lhs.getBuffer().data;
  const dr = rhs.getBuffer().data;
  const dy = output.getBuffer().data;
  for (let i = 0; i < output.size; i++) {
    const lhs = dl[i];
    const rhs = dr[i];
    dy[i] = lhs - rhs;
  }
  return output;
}

export function coresub(lhs: CPUTensor, rhs: CPUTensor): CPUTensor {
  // TODO: type check
  if (!arrayEqual(lhs.shape, rhs.shape)) {
    return subBC(lhs, rhs);
  } else {
    return subS(lhs, rhs);
  }
}
